`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/19/2022 11:15:05 PM
// Design Name: 
// Module Name: blink_led
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

/* Design Parameters
input i_sw_enable: if 1, LED will pulse based on clock. If 0, LED will remain OFF (0)
input i_sw_clk1/0: 2 bits determine different clk speed
input i_clk: 100MHZ clk generated by FPGA
output o_LED: output LED port
*/

module blink_led(
    input i_sw_enable,
    input i_sw_clk1, 
    input i_sw_clk0,
    input i_clk,
    output o_LED
    );
    
    //parameters set to count up for LED light toggle
    //input clock will be 100MHZ
    //Formula is: (FPGA clk frequency / LED frequency) * duty cycle. Assumed 50% duty cycle
    parameter c_CNT_2000mHZ = 2500000;
    parameter c_CNT_1000mHZ = 5000000;
    parameter c_CNT_100mHZ  = 50000000;
    parameter c_CNT_10mHZ   = 500000000;
    
    //Frequency count registers to store count data as it increments from clock pulses
    reg [31:0] r_CNT_2000mHZ;
    reg [31:0] r_CNT_1000mHZ;
    reg [31:0] r_CNT_100mHZ;
    reg [31:0] r_CNT_10mHZ;
    
    //register toggled at set frequencies, and will be MUX'ed to r_LED_SELECT with select lines i_sw_clk0/1
    reg        r_TOGGLE_2000mHZ = 1'b0;
    reg        r_TOGGLE_1000mHZ = 1'b0;
    reg        r_TOGGLE_100mHZ = 1'b0;
    reg        r_TOGGLE_10mHZ = 1'b0;
    
    //One bit select output to be AND'ed with enable pin to LED output. Default output set to 0
    reg        r_LED_SELECT = 1'b0;
        
    always @ (posedge i_clk)
    begin
        if (r_CNT_2000mHZ == c_CNT_2000mHZ - 1) //Counter begins at 0, so -1 needed
            begin
                r_TOGGLE_2000mHZ <= !r_TOGGLE_2000mHZ; //inverts toggle register, in turn inverting LED output if selected
                r_CNT_2000mHZ <= 0; //resets counter to 0 when reached param max
            end
        else 
            r_CNT_2000mHZ <= r_CNT_2000mHZ +1; //Increments counter by 1 if not at max
    
        if (r_CNT_1000mHZ == c_CNT_1000mHZ - 1) //Counter begins at 0, so -1 needed
            begin
                r_TOGGLE_1000mHZ <= !r_TOGGLE_1000mHZ; //inverts toggle register, in turn inverting LED output if selected
                r_CNT_1000mHZ <= 0; //resets counter to 0 when reached param max
            end
        else 
            r_CNT_1000mHZ <= r_CNT_1000mHZ +1; //Increments counter by 1 if not at max
    

        if (r_CNT_100mHZ == c_CNT_100mHZ - 1) //Counter begins at 0, so -1 needed
            begin
                r_TOGGLE_100mHZ <= !r_TOGGLE_100mHZ; //inverts toggle register, in turn inverting LED output if selected
                r_CNT_100mHZ <= 0; //resets counter to 0 when reached param max
            end
        else 
            r_CNT_100mHZ <= r_CNT_100mHZ +1; //Increments counter by 1 if not at max


        if (r_CNT_10mHZ == c_CNT_10mHZ - 1) //Counter begins at 0, so -1 needed
            begin
                r_TOGGLE_10mHZ <= !r_TOGGLE_10mHZ; //inverts toggle register, in turn inverting LED output if selected
                r_CNT_10mHZ <= 0; //resets counter to 0 when reached param max
            end
        else 
            r_CNT_10mHZ <= r_CNT_10mHZ +1; //Increments counter by 1 if not at max
    end
    
    
    always @* //* covers when any toggle register, sw_clk, or r_LED_SELECT updates
    begin
        case({i_sw_clk1, i_sw_clk0})
            2'b00: r_LED_SELECT <= r_TOGGLE_2000mHZ;
            2'b01: r_LED_SELECT <= r_TOGGLE_1000mHZ;
            2'b10: r_LED_SELECT <= r_TOGGLE_100mHZ;
            2'b11: r_LED_SELECT <= r_TOGGLE_10mHZ;
        endcase
    end
    
    //Assigns output LED, AND'ed with the selected LED from switch cases, and the enable switch
    assign o_LED = r_LED_SELECT && i_sw_enable; 

endmodule
