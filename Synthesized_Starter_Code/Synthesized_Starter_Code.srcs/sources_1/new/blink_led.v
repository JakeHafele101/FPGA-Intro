`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/19/2022 11:15:05 PM
// Design Name: 
// Module Name: blink_led
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

/* Design Parameters
input i_sw_enable: if 1, LED will pulse based on clock. If 0, LED will remain OFF (0)
input i_sw_clk1/0: 2 bits determine different clk speed
input i_clk: 100MHZ clk generated by FPGA
output o_LED: output LED port
*/

module blink_led(
    input i_sw_enable,
    input i_sw_clk1, 
    input i_sw_clk0,
    input i_clk,
    output o_LED
    );
    
    //parameters set to count up for LED light toggle
    //input clock will be 100MHZ
    //Formula is: (FPGA clk frequency / LED frequency) * duty cycle. Assumed 50% duty cycle
    parameter c_CNT_100HZ = 50000;
    parameter c_CNT_50HZ = 100000;
    parameter c_CNT_10HZ = 500000;
    parameter c_CNT_1HZ = 5000000;
    
    //Frequency count registers to store count data as it increments from clock pulses
    reg [31:0] r_CNT_100HZ;
    reg [31:0] r_CNT_50HZ;
    reg [31:0] r_CNT_10HZ;
    reg [31:0] r_CNT_1HZ;
    
    //register toggled at set frequencies, and will be MUX'ed to r_LED_SELECT with select lines i_sw_clk0/1
    reg        r_TOGGLE_100HZ = 1'b0;
    reg        r_TOGGLE_50HZ = 1'b0;
    reg        r_TOGGLE_10HZ = 1'b0;
    reg        r_TOGGLE_1HZ = 1'b0;
    
    //One bit select output to be AND'ed with enable pin to LED output. Default output set to 0
    reg        r_LED_SELECT = 1'b0;
        
    always @ (posedge i_clk)
    begin
        if (r_CNT_100HZ == c_CNT_100HZ - 1) //Counter begins at 0, so -1 needed
            begin
                r_TOGGLE_100HZ <= !r_TOGGLE_100HZ; //inverts toggle register, in turn inverting LED output if selected
                r_CNT_100HZ <= 0; //resets counter to 0 when reached param max
            end
        else 
            r_CNT_100HZ <= r_CNT_100HZ +1; //Increments counter by 1 if not at max
    
        if (r_CNT_50HZ == c_CNT_50HZ - 1) //Creates incrementing counter for 50 Hz
            begin
                r_TOGGLE_50HZ <= !r_TOGGLE_50HZ; 
                r_CNT_50HZ <= 0; 
            end
        else 
            r_CNT_50HZ <= r_CNT_50HZ +1; 
    

        if (r_CNT_10HZ == c_CNT_10HZ - 1) //Creates incrementing counter for 10 Hz
            begin
                r_TOGGLE_10HZ <= !r_TOGGLE_10HZ; 
                r_CNT_10HZ <= 0;
            end
        else 
            r_CNT_10HZ <= r_CNT_10HZ +1;


        if (r_CNT_1HZ == c_CNT_1HZ - 1) //Creates incrementing counter for 1 Hz
            begin
                r_TOGGLE_1HZ <= !r_TOGGLE_1HZ; 
                r_CNT_1HZ <= 0; 
            end
        else 
            r_CNT_1HZ <= r_CNT_1HZ +1; 
    end
    
    
    always @* //* covers when any toggle register, sw_clk, or r_LED_SELECT updates
    begin
        case({i_sw_clk1, i_sw_clk0})
            2'b00: r_LED_SELECT <= r_TOGGLE_1HZ;
            2'b01: r_LED_SELECT <= r_TOGGLE_10HZ;
            2'b10: r_LED_SELECT <= r_TOGGLE_50HZ;
            2'b11: r_LED_SELECT <= r_TOGGLE_100HZ;
        endcase
    end
    
    //Assigns output LED, AND'ed with the selected LED from switch cases, and the enable switch
    assign o_LED = r_LED_SELECT && i_sw_enable; 

endmodule
